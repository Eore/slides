chromedp: A New Way to Drive the Web
GopherCon Singapore 2017

Kenneth Shaw
ken@brank.as

26 May 2017

Tags: go, golang, chrome, chrome debugging protocol, scraping, testing, profiling

* chromedp: Introduction
- New package that provides a faster, simpler way to drive the web, enabling testing of web pages, scraping, and profiling browser performance directly in Go
- Exposes full, low-level control over a browser through the [[https://chromedevtools.github.io/devtools-protocol/][Chrome Debugging Protocol]]
- Provides high-level, reusable Actions (combinable as Tasks) to drive the browser (similar to Selenium's WebElement actions)
- No external dependencies (other than a browser)
- Being used in production today

* Old
- go + selenium package + selenium + chrome driver + chrome

* New
- go + chromedp package + headless_shell
    go get -u github.com/knq/chromedp

* Why Build It?
- Chrome Debugging Protocol supports many more features than Selenium or other automated browser framework exposes/provides access to
- Reduces dependencies (and thus complexity) for deployments (ie, no JVM, no ChromeDriver, etc)
- Browsers have been modernized: no need for Selenium, especially since most web engines in use today are WebKit/Blink derived
- Clean, maintainable code base that generates "idiomatic", type-safe, and efficient Go code
- Significantly faster (no reflection, no third-party depedency) and more reliable (significantly less errors)
- Allows 100% low-level control of launched browser processes
- Extremely small footprint (lowers costs in the Cloud)
- Take advantage of the new headless support in the Chromium source tree

* About Chrome Debugging Protocol
- More-or-less the same API used internally by Chrome DevTools
- Exposes low-level control for most aspects of browser, such as ability to start/stop/pause/modify network requests, inject Javascript, alter page elements, step-through running Javascript, etc.
- "Async"

* How the CDP Works
- Chrome Debugging Protocol is maintained by 2 files (browser_protocol.json + js_protocol.json) in the Chromium source tree
- The files are combined to create protocol.json which defines the constituent Chrome Debugging Protocol Domains
- Domains are high-level areas of concern within the Chromium source/API: ie, Network, Page, DOM, Input, Network, IO, etc.
- Each domain defines a set of Commands, Events, and various Types
- JSON protocol provides 1:1 mapping of "Targets" to Chrome instances (ie, a "Tab" / "Page")
- Commands and Events are sent over a simple WebSocket connection, and are JSON-encoded

* CDP Resources
- [[https://chromedevtools.github.io/devtools-protocol/][Chrome DevTools Protocol Viewer]] - Chrome Debugging Protocol Domain Documentation
- [[http://remotedebug.org/][RemoteDebug]] - General browser debugging information
- [[https://github.com/knq/chrome-headless][knq/chrome-headless]] - headless_shell Docker images (knqz/chrome-headless)
- [[https://github.com/knq/chromium-builder][knq/chromium-builder]] - Chromium build environment (knqz/chromium-builder)

* Low-level Protocol Generation (chromedp-gen)
- [[https://github.com/knq/chromedp/tree/master/cmd/chromedp-gen][chromedp/cmd/chromedp-gen]] is a standalone tool to generate the CDP protocol layer from the protocol.json
- Reads [[https://github.com/knq/chromedp/blob/master/cmd/chromedp-gen/protocol.json][protocol.json]] into simple Go types
- Applies "fixups" to the types/APIs defined by the type hierarchy so generated code is without cyclical package dependencies and is "idiomatic"
- A package for each CDP domain is generated by applying [[https://github.com/valyala/quicktemplate][valyala/quicktemplate]] based templates to each
- JSON encoders/decoders for types generated using [[https://github.com/mailru/easyjson][mailru/easyjson]]
- Generated API inspired by [[https://github.com/google/google-api-go-client][google/google-api-go-client]]
- Generated domain code handles some high-level features like base64 encoding/decoding

* Using Generated Domain APIs
- Generated CDP commands have form of:
    import "github.com/knq/chromedp/cdp/domain"

    result1, result2, err := domain.CommandName(param1, param2).
        WithOption1(option1).
        Do(context, handler)

    // note: domain.CommandName() just returns *domain.CommandNameParam (a struct type)

- Example: sending a raw mouse event
    err := input.DispatchMouseEvent(input.MouseMoved, 15, 10).
        WithButton(input.ButtonLeft).
        Do(context, handler)

- Example: page navigation
    frameID, err := page.Navigate("http://brank.as/").Do(context, handler)

* chromedp Packages
- Package [[https://godoc.org/github.com/knq/chromedp/client][chromedp/client]] provides the low-level JSON/WebSocket communication components
- Package [[https://godoc.org/github.com/knq/chromedp/runner][chromedp/runner]] provides a wrapper around launching an instance of Chrome, Edge, headless_shell, etc., via os/exec
- Package [[https://godoc.org/github.com/knq/chromedp/cdp][chromedp/cdp]] is the root of the generated low-level code Domain packages and contains the most important types (Frame + Node)
- Package [[https://godoc.org/github.com/knq/chromedp][chromedp]] provides high-level APIs (actions + tasks) to connect clients, runners, and the low level CDP domain protocol

* Quick Intro to Using chromedp
	import (
		cdp "github.com/knq/chromedp"
		cdptypes "github.com/knq/chromedp/cdp"
	)
	
	// create a context
	ctxt, cancel := context.WithCancel(context.Background())
	defer cancel()
	
	// start a chrome instance, and connect client
	c, err := cdp.New(ctxt, cdp.WithLog(log.Printf))
	
	// run an action/task list
	err = c.Run(ctxt, tasks())
	
	// shutdown chrome instance
	err = c.Shutdown(ctxt)
	
	// wait for shutdown to finish
	err = c.Wait()

* Actions + Tasks
- Actions are high-level wrappers around common browser tasks (ie, "click a button matching CSS selector X")
- chromedp.Action defines the common interface that all actions (and generated domain commands!) match:
    type Action interface {
        Do(context.Context, cdp.Handler) error
    }

- chromedp.Tasks wraps a slice of Actions that will be executed sequentially (also satisfies the Action interface):
    type Tasks []Action

- Because Tasks satisfies the Action interface, tasks are composable:
	t := chromedp.Tasks{chromedp.Tasks{mypackage.MyTasks()}, ...}

* Example

.code src/quick.go /^func google/,/^}/

* Unit testing with chromedp
- Best examples are in the chromedp source tree
- Use with headless_shell
- Do standard Go testing (ie, Test*)
- Pool helper provides a wrapper for launching multiple headless processes
	p, err := chromedp.NewPool()
	defer p.Shutdown()

	r, err := p.Allocate(context, commandLineOptions)
	defer r.Release()

	err = r.Run(context, task)
- No need for a testing DSL; use Go!

* Future
- Fully embeddable (remove all external dependencies completely)
- Increase performance (even more!)
- More/better high-level actions
- Out-of-the-box profiling

* Brankas
- We're hiring!
- Email [[mailto:ken@brank.as][ken@brank.as]]

- If you're in Indonesia, join [[https://meetup.com/GoJakarta][GoJakarta]]!

- Give some love to [[https://github.com/knq/usql][usql]] and [[https://github.com/knq/xo][xo]]!

- Thanks to Randy Cahyana for writing the unit tests!
